import time

"""
                                time.process_time()

Type:
    builtin_function_or_method (Returns: float)
Return Value:
    A float representing the sum of the system and user CPU time of the current process (in fractional seconds).
    - It measures "effort", not "duration".
    - It does NOT include time elapsed during sleep.
Use Cases:
    1. Profiling CPU-intensive code blocks to measure efficiency.
    2. Benchmarking algorithms while excluding external delays (like network/disk I/O or sleep).
    3. Monitoring the CPU load generated by a specific process.
Notes:
    - Reference Point: Undefined. Only the difference between two calls is valid.
    - Scope: Process-wide (current process).
"""
print("\n---------------- time.process_time() ----------------")

start_time = time.process_time()

# x = [i**2 for i in range(100_000_000)]

print("Sleeping for 2 seconds...")
# time.sleep(2)

end_time = time.process_time()

cpu_time_used = end_time - start_time
print(f"CPU time used: {cpu_time_used} seconds")


"""
                                time.perf_counter()

Type:
    builtin_function_or_method (Returns: float)
Return Value:
    A float representing the value of a performance counter (in fractional seconds).
    - It provides the highest available resolution to measure a short duration.
    - It INCLUDES time elapsed during sleep.
Use Cases:
    1. Benchmarking execution time where high precision is required.
    2. Measuring total elapsed time for operations including I/O waits and sleeps.
    3. Performance testing across different processes (clock is system-wide).
Notes:
    - Reference Point: Undefined. Only the difference between two calls is valid.
    - Monotonicity: The clock cannot go backwards (CPython implementation).
    - Scope: System-wide (same for all processes).
"""
print("\n---------------- time.perf_counter() ----------------")


start_time = time.perf_counter()

# x = [i**2 for i in range(100_000_000)]

print("Sleeping for 2 seconds...")
# time.sleep(2)

end_time = time.perf_counter()

elapsed_time = end_time - start_time
print(f"Elapsed time: {elapsed_time} seconds")


"""
                                time.sleep(secs)

Type:
    builtin_function_or_method (Returns: None)
Arguments:
    secs (float or int): The number of seconds to suspend execution. 
    - Accepts floating-point numbers for sub-second precision (e.g., 0.5 for 500ms).
Behavior:
    Suspends the execution of the calling thread for the specified duration.
    - The thread releases the CPU during this time, allowing other tasks/programs to run.
Use Cases:
    1. Rate Limiting: Slowing down a loop (e.g., checking an API every 10 seconds).
    2. Polling: Waiting between checks for a condition (to avoid 100% CPU usage).
    3. Simulation: Artificially adding delays (e.g., UI loading states).
Warning:
    - The actual suspension time may be LONGER than requested due to OS scheduling.
    - sleep(0) is not a "no-op" (do nothing); it is a request to yield the CPU slice.
"""
print("\n---------------- time.sleep(secs) ----------------")


start = time.perf_counter()
time.sleep(1)
end = time.perf_counter()

print(f"Slept for approximately: {end - start} seconds when sleeping for 1 second.")

start = time.perf_counter()
time.sleep(0)
end = time.perf_counter()

print(f"Slept for approximately: {end - start} seconds when sleeping for 0 seconds.")


def do_nothing():
    pass  # Compiles to a NOP (No Operation), costs almost 0 time.


def yield_cpu():
    time.sleep(0)  # Tells OS: "I'm done with my turn, let someone else run."
